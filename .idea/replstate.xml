<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1466001516234">{:repl-history {:ide [], :local [&quot;(:jdbc.user @*props-map*)&quot; &quot;(c/to-sql-date (f/parse date-formatter \&quot;04-06-2016\&quot;))&quot; &quot;(find-all-campaign)&quot; &quot;(numeric? \&quot;1\&quot;)&quot; &quot;(numeric? \&quot;\&quot;)&quot; &quot;(numeric? 1)&quot; &quot;(numeric? nil)&quot; &quot;(if (numeric? nil) true false)&quot; &quot;(def num nil)&quot; &quot;(def my-num nil)&quot; &quot;(def my-num \&quot;he\&quot;)&quot; &quot;(cond\n  (nil? my-num) 0\n  (numeric? my-num) (Integer/parseInt my-num)\n  :else\n  (throw+ {:type :validation-exception :message \&quot;offset must be numeric\&quot; :developer-message \&quot;Expects numeric value for URL parameter offset\&quot;}))&quot; &quot;(str (:offset {}))&quot; &quot;(find-all-campaign {})&quot; &quot;(find-campaign-messages {:campaign_id 1})&quot; &quot;(create-campaign\n  {:campaign_type    1,\n   :start_date       \&quot;04-06-2016\&quot;,\n   :end_date         \&quot;04-06-2016\&quot;,\n   :cron_expression  \&quot;0 0 1 * *\&quot;,\n   :created_by       1,\n   :tenant_id        \&quot;default\&quot;,\n   :campaign_name    \&quot;Test Campaign\&quot;,\n   :message_template \&quot;Dear {{first_name}}\&quot;})&quot; &quot;(create-campaign\n  {:campaign_type    1,\n   :start_date       \&quot;04-06-2016\&quot;,\n   :end_date         \&quot;06-06-2016\&quot;,\n   :cron_expression  \&quot;0 0 1 * *\&quot;,\n   :created_by       1,\n   :tenant_id        \&quot;default\&quot;,\n   :campaign_name    \&quot;Test Campaign\&quot;,\n   :message_template \&quot;Dear {{first_name}}\&quot;})&quot; &quot;(create-campaign\n  {:campaign_type    1,\n   :start_date       \&quot;04-06-2016\&quot;,\n   :end_date         \&quot;05-06-2016\&quot;,\n   :cron_expression  \&quot;0 0 1 * *\&quot;,\n   :created_by       1,\n   :tenant_id        \&quot;default\&quot;,\n   :campaign_name    \&quot;Test Campaign\&quot;,\n   :message_template \&quot;Dear {{first_name}}\&quot;})&quot; &quot;(create-campaign\n  {:campaign_type    1,\n   :start_date       \&quot;04-06-2016\&quot;,\n   :end_date         \&quot;10-06-2016\&quot;,\n   :cron_expression  \&quot;0 0 1 * *\&quot;,\n   :created_by       1,\n   :tenant_id        \&quot;default\&quot;,\n   :campaign_name    \&quot;Test Campaign\&quot;,\n   :message_template \&quot;Dear {{first_name}}\&quot;})&quot; &quot;(fetch-active-campaigns {:offset 0\n                         :limit 50})&quot; &quot;(:mifos.api.base *props-map*)&quot; &quot;(:mifos.api.base @*props-map*)&quot; &quot;(str 1)&quot; &quot;(fetch-mifos 1 \&quot;default\&quot;)&quot; &quot;(:mifos.api.user @*props-map*) (:mifos.api.password *props-map*)&quot; &quot;(:mifos.api.password *props-map*)&quot; &quot;(try\n  (fetch-mifos 1 \&quot;default\&quot;)\n  (catch Exception e\n    (.printStackTrace e)))&quot; &quot;(try\n  (fetch-mifos-active-clients 1 \&quot;default\&quot;)\n  (catch Exception e\n    (.printStackTrace e)))&quot; &quot;(try\n  (fetch-mifos-active-clients \&quot;default\&quot;)\n  (catch Exception e\n    (.printStackTrace e)))&quot; &quot;*props-map*&quot; &quot;(clojure.string/replace \&quot;rabbitmq.host\&quot; #\&quot;.\&quot; \&quot;-\&quot;)&quot; &quot;(clojure.string/replace \&quot;rabbitmq.host\&quot; \&quot;.\&quot; \&quot;-\&quot;)&quot; &quot;(clojure.string/replace \&quot;mifos.api.base\&quot; \&quot;.\&quot; \&quot;-\&quot;)&quot; &quot;(clojure.string/replace \&quot;mifosapibase\&quot; \&quot;.\&quot; \&quot;-\&quot;)&quot; &quot;(init)&quot; &quot;@*is-crontab-initialized*&quot; &quot;(jobs/schedule \&quot;* * * * *\&quot; (fn [] (println \&quot;A simple task.\&quot;)))&quot; &quot;; And start the scheduler\n(jobs/start)&quot; &quot;(jobs/job \&quot;9014e65e26a8e70d30d950ad0000015525ffcec97e2cb860\&quot;)&quot; &quot;(initialized?)&quot; &quot;(jobs/initialized?)&quot; &quot;(some #(= 5 %) [1 2 3 4 5])&quot; &quot;(some #(= 7 %) [1 2 3 4 5])&quot; &quot;(some #(= 7 (:a %)) [{:a 2 :b 45} {:a 3 :b 5} {:a 4 :b 3}])&quot; &quot;(some #(= 2 (:a %)) [{:a 2 :b 45} {:a 3 :b 5} {:a 4 :b 3}])&quot; &quot;@*props-map*&quot; &quot;(data/fetch-active-campaigns {:limit 50\n                              :offset 0})&quot; &quot;(data/fetch-active-campaigns )&quot; &quot;(parse-cron-expr \&quot;* * * * *\&quot;)&quot; &quot;(parse-cron-expr \&quot;0 0 1 * *\&quot;)&quot; &quot;(require '[clj-cron-parse.core :refer [next-date]])&quot; &quot;(def next-every-second\n  (next-date now \&quot;1 * * * * *\&quot;))&quot; &quot;(require '[clj-time.local :as l])&quot; &quot;(def next-every-second\n  (next-date (l/local-now) \&quot;1 * * * * *\&quot;))&quot; &quot;(def next-every-second\n  (next-date (l/local-now) \&quot;0 0 1 * *\&quot;))&quot; &quot;next-every-second&quot; &quot;(if 0 false true)&quot; &quot;(if 1 false true)&quot; &quot;(fetch-active-campaigns )&quot; &quot;(def myte (atom {}))&quot; &quot;(swap! myte assoc :id 12345)&quot; &quot;@myte&quot; &quot;(= \&quot;1\&quot; (str 1))&quot; &quot;(def x (atom (vector 1 2 3 4)))&quot; &quot;(reset! x (vector))&quot; &quot;@x&quot; &quot;(data/fetch-active-campaigns)&quot; &quot;@active-crons&quot; &quot;(jobs/all-jobs)&quot; &quot;(load-active-campaigns)&quot; &quot;(jobs/jobs)&quot; &quot;jobs/all-jobs&quot; &quot;@jobs/all-jobs&quot; &quot;(-&gt; :id {:id 1, :name \&quot;Active clients\&quot;})&quot; &quot;(-&gt; :id {:id 1, :name \&quot;Active clients\&quot;} str)&quot; &quot;(-&gt; \&quot;{\\\&quot;id\\\&quot;:1,\\\&quot;name\\\&quot;:\\\&quot;Active clients\\\&quot;}\&quot; json/parse-string :id)&quot; &quot;(-&gt; \&quot;{\\\&quot;id\\\&quot;:1,\\\&quot;name\\\&quot;:\\\&quot;Active clients\\\&quot;}\&quot; json/parse-string )&quot; &quot;(-&gt;  json/parse-string \&quot;{\\\&quot;id\\\&quot;:1,\\\&quot;name\\\&quot;:\\\&quot;Active clients\\\&quot;}\&quot; )&quot; &quot;(def rec 0)&quot; &quot;(def rec (atom 0))&quot; &quot;(swap! rec inc)&quot; &quot;(def mapd (vector\n            {:a 1}\n            {:a 2}\n            {:a 3}\n            {:a 4}\n            {:a 5}\n            {:a 6}))&quot; &quot;(map (fn [c] \n       (assoc c :b (+ (:a c) 1))))&quot; &quot;(map (fn [c] \n       (assoc c :b (+ (:a c) 1))) mapd)&quot; &quot;(def foo (conj (lazy-seq [1 2 3]) 0))&quot; &quot;(def foo (lazy-seq [1 2 3]))&quot; &quot;foo&quot; &quot;(fetch-sent-messages)&quot; &quot;;;Add org.joda.time.DateTime Json encoder\n(add-encoder org.joda.time.DateTime\n             (fn [c jsonGenerator]\n                 (.writeString jsonGenerator (f/unparse cheshire-formatter c))))\n;;initialize SMS Queue handler\n(sms/initialize-sms-interface)&quot; &quot;(add-encoder org.joda.time.DateTime\n             (fn [c jsonGenerator]\n               (.writeString jsonGenerator (f/unparse cheshire-formatter c))))\n;;initialize SMS Queue handler&quot; &quot;(data/fetch-sent-messages 0 50)&quot; &quot;(fetch-sent-messages {})&quot; &quot;(fetch-sent-messages \&quot;2016-06-12\&quot; \&quot;2016-06-13\&quot;)&quot; &quot;(fetch-sent-messages \&quot;REJECTED_NOT_ENOUGH_CREDITS\&quot; \&quot;2016-06-12\&quot; \&quot;2016-06-13\&quot;)&quot; &quot;(fetch-sent-messages \&quot;REJECTED_NOT_ENOUGH_CREDITS\&quot; \&quot;2016-06-12\&quot; \&quot;2016-06-12\&quot;)&quot; &quot;(fetch-sent-messages {:smsStatus \&quot;REJECTED_NOT_ENOUGH_CREDITS\&quot; \n                      :startDate \&quot;2016-06-12\&quot; \n                      :endDate \&quot;2016-06-12\&quot;})&quot;], :remote []}}</component>
</project>